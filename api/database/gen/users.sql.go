// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package database_gen

import (
	"context"
	"database/sql"

	"github.com/TDiblik/project-template/api/models"
	"github.com/google/uuid"
)

const checkEmailExists = `-- name: CheckEmailExists :one
SELECT EXISTS(
    SELECT 1 FROM users
    WHERE email = $1
       OR github_email = $1
       OR google_email = $1
       OR facebook_email = $1
       OR spotify_email = $1
)
`

// Corresponds to utils.UserEmailExistsQuery
func (q *Queries) CheckEmailExists(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkEmailExists, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkHandleExists = `-- name: CheckHandleExists :one
SELECT EXISTS(SELECT 1 FROM users WHERE handle = $1)
`

func (q *Queries) CheckHandleExists(ctx context.Context, handle sql.NullString) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkHandleExists, handle)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    email, email_verified, password_hash, handle, first_name, last_name, avatar_url,
    github_id, github_email, github_handle, github_url,
    google_id, google_email,
    facebook_id, facebook_email, facebook_url,
    spotify_id, spotify_email, spotify_url
) VALUES (
    $1, $2, $3, $4, $5, $6, $7,
    $8, $9, $10, $11,
    $12, $13,
    $14, $15, $16,
    $17, $18, $19
)
RETURNING id, email, email_verified, password_hash, first_name, last_name, handle, full_name, initials, avatar_url, active, prefered_theme, prefered_language, github_id, github_email, github_handle, github_url, google_id, google_email, facebook_id, facebook_email, facebook_url, spotify_id, spotify_email, spotify_url, last_login_at, created_at, updated_at
`

type CreateUserParams struct {
	Email         string               `db:"email" json:"email"`
	EmailVerified sql.NullBool         `db:"email_verified" json:"email_verified"`
	PasswordHash  sql.NullString       `db:"password_hash" json:"password_hash"`
	Handle        sql.NullString       `db:"handle" json:"handle"`
	FirstName     sql.NullString       `db:"first_name" json:"first_name"`
	LastName      sql.NullString       `db:"last_name" json:"last_name"`
	AvatarUrl     models.SQLNullString `db:"avatar_url" json:"avatar_url"`
	GithubID      models.SQLNullString `db:"github_id" json:"github_id"`
	GithubEmail   models.SQLNullString `db:"github_email" json:"github_email"`
	GithubHandle  models.SQLNullString `db:"github_handle" json:"github_handle"`
	GithubUrl     models.SQLNullString `db:"github_url" json:"github_url"`
	GoogleID      models.SQLNullString `db:"google_id" json:"google_id"`
	GoogleEmail   models.SQLNullString `db:"google_email" json:"google_email"`
	FacebookID    models.SQLNullString `db:"facebook_id" json:"facebook_id"`
	FacebookEmail models.SQLNullString `db:"facebook_email" json:"facebook_email"`
	FacebookUrl   models.SQLNullString `db:"facebook_url" json:"facebook_url"`
	SpotifyID     models.SQLNullString `db:"spotify_id" json:"spotify_id"`
	SpotifyEmail  models.SQLNullString `db:"spotify_email" json:"spotify_email"`
	SpotifyUrl    models.SQLNullString `db:"spotify_url" json:"spotify_url"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Email,
		arg.EmailVerified,
		arg.PasswordHash,
		arg.Handle,
		arg.FirstName,
		arg.LastName,
		arg.AvatarUrl,
		arg.GithubID,
		arg.GithubEmail,
		arg.GithubHandle,
		arg.GithubUrl,
		arg.GoogleID,
		arg.GoogleEmail,
		arg.FacebookID,
		arg.FacebookEmail,
		arg.FacebookUrl,
		arg.SpotifyID,
		arg.SpotifyEmail,
		arg.SpotifyUrl,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.Handle,
		&i.FullName,
		&i.Initials,
		&i.AvatarUrl,
		&i.Active,
		&i.PreferedTheme,
		&i.PreferedLanguage,
		&i.GithubID,
		&i.GithubEmail,
		&i.GithubHandle,
		&i.GithubUrl,
		&i.GoogleID,
		&i.GoogleEmail,
		&i.FacebookID,
		&i.FacebookEmail,
		&i.FacebookUrl,
		&i.SpotifyID,
		&i.SpotifyEmail,
		&i.SpotifyUrl,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserAuthByEmail = `-- name: GetUserAuthByEmail :one
SELECT id, password_hash
FROM users
WHERE email = $1
   OR github_email = $1
   OR google_email = $1
   OR facebook_email = $1
   OR spotify_email = $1
LIMIT 1
`

type GetUserAuthByEmailRow struct {
	ID           uuid.UUID      `db:"id" json:"id"`
	PasswordHash sql.NullString `db:"password_hash" json:"password_hash"`
}

// Corresponds to utils.SelectIdAndPasswordHashByEmailQuery
func (q *Queries) GetUserAuthByEmail(ctx context.Context, email string) (GetUserAuthByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getUserAuthByEmail, email)
	var i GetUserAuthByEmailRow
	err := row.Scan(&i.ID, &i.PasswordHash)
	return i, err
}

const getUserByEmailOrOauth = `-- name: GetUserByEmailOrOauth :one
SELECT id, email, email_verified, password_hash, first_name, last_name, handle, full_name, initials, avatar_url, active, prefered_theme, prefered_language, github_id, github_email, github_handle, github_url, google_id, google_email, facebook_id, facebook_email, facebook_url, spotify_id, spotify_email, spotify_url, last_login_at, created_at, updated_at FROM users
WHERE email = $1
   OR github_email = $1
   OR google_email = $1
   OR facebook_email = $1
   OR spotify_email = $1
LIMIT 1
`

// Corresponds to utils.SelectUserByEmailQuery
func (q *Queries) GetUserByEmailOrOauth(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmailOrOauth, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.Handle,
		&i.FullName,
		&i.Initials,
		&i.AvatarUrl,
		&i.Active,
		&i.PreferedTheme,
		&i.PreferedLanguage,
		&i.GithubID,
		&i.GithubEmail,
		&i.GithubHandle,
		&i.GithubUrl,
		&i.GoogleID,
		&i.GoogleEmail,
		&i.FacebookID,
		&i.FacebookEmail,
		&i.FacebookUrl,
		&i.SpotifyID,
		&i.SpotifyEmail,
		&i.SpotifyUrl,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, email, email_verified, password_hash, first_name, last_name, handle, full_name, initials, avatar_url, active, prefered_theme, prefered_language, github_id, github_email, github_handle, github_url, google_id, google_email, facebook_id, facebook_email, facebook_url, spotify_id, spotify_email, spotify_url, last_login_at, created_at, updated_at FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserById(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.Handle,
		&i.FullName,
		&i.Initials,
		&i.AvatarUrl,
		&i.Active,
		&i.PreferedTheme,
		&i.PreferedLanguage,
		&i.GithubID,
		&i.GithubEmail,
		&i.GithubHandle,
		&i.GithubUrl,
		&i.GoogleID,
		&i.GoogleEmail,
		&i.FacebookID,
		&i.FacebookEmail,
		&i.FacebookUrl,
		&i.SpotifyID,
		&i.SpotifyEmail,
		&i.SpotifyUrl,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setLastLoginNow = `-- name: SetLastLoginNow :one
UPDATE users
SET last_login_at = NOW()
WHERE id = $1
RETURNING id, email, email_verified, password_hash, first_name, last_name, handle, full_name, initials, avatar_url, active, prefered_theme, prefered_language, github_id, github_email, github_handle, github_url, google_id, google_email, facebook_id, facebook_email, facebook_url, spotify_id, spotify_email, spotify_url, last_login_at, created_at, updated_at
`

// Used in GetJwtPostLogin
func (q *Queries) SetLastLoginNow(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, setLastLoginNow, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.Handle,
		&i.FullName,
		&i.Initials,
		&i.AvatarUrl,
		&i.Active,
		&i.PreferedTheme,
		&i.PreferedLanguage,
		&i.GithubID,
		&i.GithubEmail,
		&i.GithubHandle,
		&i.GithubUrl,
		&i.GoogleID,
		&i.GoogleEmail,
		&i.FacebookID,
		&i.FacebookEmail,
		&i.FacebookUrl,
		&i.SpotifyID,
		&i.SpotifyEmail,
		&i.SpotifyUrl,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserAvatar = `-- name: UpdateUserAvatar :one
UPDATE users SET
    avatar_url = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, email, email_verified, password_hash, first_name, last_name, handle, full_name, initials, avatar_url, active, prefered_theme, prefered_language, github_id, github_email, github_handle, github_url, google_id, google_email, facebook_id, facebook_email, facebook_url, spotify_id, spotify_email, spotify_url, last_login_at, created_at, updated_at
`

type UpdateUserAvatarParams struct {
	ID        uuid.UUID            `db:"id" json:"id"`
	AvatarUrl models.SQLNullString `db:"avatar_url" json:"avatar_url"`
}

// Used in PostUserMeAvatarHandler
func (q *Queries) UpdateUserAvatar(ctx context.Context, arg UpdateUserAvatarParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserAvatar, arg.ID, arg.AvatarUrl)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.Handle,
		&i.FullName,
		&i.Initials,
		&i.AvatarUrl,
		&i.Active,
		&i.PreferedTheme,
		&i.PreferedLanguage,
		&i.GithubID,
		&i.GithubEmail,
		&i.GithubHandle,
		&i.GithubUrl,
		&i.GoogleID,
		&i.GoogleEmail,
		&i.FacebookID,
		&i.FacebookEmail,
		&i.FacebookUrl,
		&i.SpotifyID,
		&i.SpotifyEmail,
		&i.SpotifyUrl,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserFull = `-- name: UpdateUserFull :one
UPDATE users SET
    password_hash = COALESCE(NULLIF($2, ''), password_hash), -- Update only if new value is provided
    handle = COALESCE($3, handle),
    first_name = COALESCE($4, first_name),
    last_name = COALESCE($5, last_name),
    avatar_url = COALESCE($6, avatar_url),
    email_verified = $7,

    github_id = COALESCE($8, github_id),
    github_email = COALESCE($9, github_email),
    github_handle = COALESCE($10, github_handle),
    github_url = COALESCE($11, github_url),

    google_id = COALESCE($12, google_id),
    google_email = COALESCE($13, google_email),

    facebook_id = COALESCE($14, facebook_id),
    facebook_email = COALESCE($15, facebook_email),
    facebook_url = COALESCE($16, facebook_url),

    spotify_id = COALESCE($17, spotify_id),
    spotify_email = COALESCE($18, spotify_email),
    spotify_url = COALESCE($19, spotify_url),

    updated_at = NOW()
WHERE id = $1
RETURNING id, email, email_verified, password_hash, first_name, last_name, handle, full_name, initials, avatar_url, active, prefered_theme, prefered_language, github_id, github_email, github_handle, github_url, google_id, google_email, facebook_id, facebook_email, facebook_url, spotify_id, spotify_email, spotify_url, last_login_at, created_at, updated_at
`

type UpdateUserFullParams struct {
	ID            uuid.UUID            `db:"id" json:"id"`
	Column2       interface{}          `db:"column_2" json:"column_2"`
	Handle        sql.NullString       `db:"handle" json:"handle"`
	FirstName     sql.NullString       `db:"first_name" json:"first_name"`
	LastName      sql.NullString       `db:"last_name" json:"last_name"`
	AvatarUrl     models.SQLNullString `db:"avatar_url" json:"avatar_url"`
	EmailVerified sql.NullBool         `db:"email_verified" json:"email_verified"`
	GithubID      models.SQLNullString `db:"github_id" json:"github_id"`
	GithubEmail   models.SQLNullString `db:"github_email" json:"github_email"`
	GithubHandle  models.SQLNullString `db:"github_handle" json:"github_handle"`
	GithubUrl     models.SQLNullString `db:"github_url" json:"github_url"`
	GoogleID      models.SQLNullString `db:"google_id" json:"google_id"`
	GoogleEmail   models.SQLNullString `db:"google_email" json:"google_email"`
	FacebookID    models.SQLNullString `db:"facebook_id" json:"facebook_id"`
	FacebookEmail models.SQLNullString `db:"facebook_email" json:"facebook_email"`
	FacebookUrl   models.SQLNullString `db:"facebook_url" json:"facebook_url"`
	SpotifyID     models.SQLNullString `db:"spotify_id" json:"spotify_id"`
	SpotifyEmail  models.SQLNullString `db:"spotify_email" json:"spotify_email"`
	SpotifyUrl    models.SQLNullString `db:"spotify_url" json:"spotify_url"`
}

// Used in CreateOrUpdateUser to merge accounts
func (q *Queries) UpdateUserFull(ctx context.Context, arg UpdateUserFullParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserFull,
		arg.ID,
		arg.Column2,
		arg.Handle,
		arg.FirstName,
		arg.LastName,
		arg.AvatarUrl,
		arg.EmailVerified,
		arg.GithubID,
		arg.GithubEmail,
		arg.GithubHandle,
		arg.GithubUrl,
		arg.GoogleID,
		arg.GoogleEmail,
		arg.FacebookID,
		arg.FacebookEmail,
		arg.FacebookUrl,
		arg.SpotifyID,
		arg.SpotifyEmail,
		arg.SpotifyUrl,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.Handle,
		&i.FullName,
		&i.Initials,
		&i.AvatarUrl,
		&i.Active,
		&i.PreferedTheme,
		&i.PreferedLanguage,
		&i.GithubID,
		&i.GithubEmail,
		&i.GithubHandle,
		&i.GithubUrl,
		&i.GoogleID,
		&i.GoogleEmail,
		&i.FacebookID,
		&i.FacebookEmail,
		&i.FacebookUrl,
		&i.SpotifyID,
		&i.SpotifyEmail,
		&i.SpotifyUrl,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserPreferences = `-- name: UpdateUserPreferences :one
UPDATE users SET
    first_name = COALESCE(NULLIF($1::text, ''), first_name),
    last_name = COALESCE(NULLIF($2::text, ''), last_name),
    prefered_theme = COALESCE(NULLIF($3::text, ''), prefered_theme),
    prefered_language = COALESCE(NULLIF($4::text, ''), prefered_language),
    updated_at = NOW()
WHERE id = $5
RETURNING id, email, email_verified, password_hash, first_name, last_name, handle, full_name, initials, avatar_url, active, prefered_theme, prefered_language, github_id, github_email, github_handle, github_url, google_id, google_email, facebook_id, facebook_email, facebook_url, spotify_id, spotify_email, spotify_url, last_login_at, created_at, updated_at
`

type UpdateUserPreferencesParams struct {
	FirstName        string    `db:"first_name" json:"first_name"`
	LastName         string    `db:"last_name" json:"last_name"`
	PreferedTheme    string    `db:"prefered_theme" json:"prefered_theme"`
	PreferedLanguage string    `db:"prefered_language" json:"prefered_language"`
	ID               uuid.UUID `db:"id" json:"id"`
}

// Used in PatchUserMeHandler
func (q *Queries) UpdateUserPreferences(ctx context.Context, arg UpdateUserPreferencesParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserPreferences,
		arg.FirstName,
		arg.LastName,
		arg.PreferedTheme,
		arg.PreferedLanguage,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.Handle,
		&i.FullName,
		&i.Initials,
		&i.AvatarUrl,
		&i.Active,
		&i.PreferedTheme,
		&i.PreferedLanguage,
		&i.GithubID,
		&i.GithubEmail,
		&i.GithubHandle,
		&i.GithubUrl,
		&i.GoogleID,
		&i.GoogleEmail,
		&i.FacebookID,
		&i.FacebookEmail,
		&i.FacebookUrl,
		&i.SpotifyID,
		&i.SpotifyEmail,
		&i.SpotifyUrl,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
